<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ativar assinatura</title>
  <link rel="stylesheet" href="/assets/app.css" />

  <!-- ✅ Só UI: esconde infos técnicas (mantém no HTML para não quebrar o JS) -->
  <style>
    /* O bloco técnico continua existindo (para o código), mas o usuário não vê */
    #statusBox { display: none !important; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="topbar">
        <div class="brand">
          <span class="dot"></span>
          <div>
            <div style="font-size:18px; line-height:1; font-weight:900;">Liberdade Financeira</div>
            <div class="muted small">Ativar assinatura</div>
          </div>
        </div>
        <div class="badge" id="netBadge">Rede: <b style="margin-left:6px">-</b></div>
      </div>

      <div class="section grid" style="gap:18px;">
        <div>
          <h1 style="margin:0 0 6px;font-size:34px;letter-spacing:-0.02em;">Ativar assinatura</h1>
          <p class="muted" style="margin:0;">
            Para liberar o acesso ao dashboard, você vai usar <b>uma única carteira</b>:
            ela será usada para <b>pagar a assinatura</b> e também para <b>receber suas comissões</b>.
          </p>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">No celular</div>
          <div class="muted" style="margin-bottom:10px;">
            Para assinar pelo celular, o ideal é abrir esta página dentro do navegador do MetaMask.
          </div>
          <button class="btn primary" id="btnOpenMM">Abrir no MetaMask</button>
          <div class="small muted" style="margin-top:10px;">
            Se aparecer um aviso “prossiga com cautela”, é normal: você está abrindo um dApp externo.
          </div>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">Antes de continuar</div>

          <div class="grid" style="gap:10px;">
            <div class="muted">
              <b>Você precisa ter na sua carteira:</b><br/>
              • <b>BNB</b> (taxas de rede)<br/>
              • <b>USDT</b> (assinatura)
            </div>

            <div class="muted">
              ✅ Forma mais simples de preparar (recomendado):<br/>
              1) Deposite <b>USDT</b> na sua carteira<br/>
              2) Troque uma pequena parte por <b>BNB</b> (taxas de rede)<br/>
              3) Deixe o restante em <b>USDT</b> para a assinatura
            </div>

            <div class="small muted">
              <b>Taxa de rede:</b> na primeira autorização (approve), será cobrada uma taxa pequena em <b>BNB</b>.
            </div>
          </div>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">Carteira principal</div>

          <div class="muted" style="margin-bottom:10px;">
            Cole abaixo o endereço da sua carteira (0x...). Se preferir, você pode conectar o MetaMask
            para preencher automaticamente.
          </div>

          <input class="input" id="walletInput" placeholder="Cole aqui o endereço (0x...)" />

          <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
            <button class="btn" id="btnConnect">Conectar MetaMask (opcional)</button>
            <button class="btn" id="btnSave">Salvar carteira</button>
            <button class="btn ghost" id="btnCheck">Verificar saldos</button>
          </div>

          <div class="muted small" id="savedInfo" style="margin-top:10px;display:none;"></div>

          <div class="muted" id="balancesBox" style="margin-top:10px;display:none;">
            <div class="badge" style="margin-bottom:8px;">Saldos</div>
            <div>• BNB: <b id="balBNB">-</b></div>
            <div>• USDT: <b id="balUSDT">-</b></div>
            <div class="small muted" id="balHint" style="margin-top:8px;display:none;"></div>
          </div>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">Ativar acesso</div>

          <button class="btn primary" id="btnSubscribe" style="width:100%;font-size:18px;">
            Ativar assinatura
          </button>

          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
            <button class="btn ghost" id="btnRenew" style="flex:1; min-width:220px;">
              Renovar agora
            </button>
            <button class="btn ghost" id="btnRefresh" style="flex:1; min-width:220px;">
              Atualizar status
            </button>
          </div>

          <div class="small muted" style="margin-top:10px;">
            No primeiro uso, o MetaMask vai pedir uma confirmação extra para autorizar o débito do USDT (approve).
            Depois, você assina a transação de assinatura (subscribe) e o acesso é liberado.
          </div>

          <div id="txBox" class="muted" style="margin-top:12px; display:none;">
            <div class="badge" style="margin-bottom:8px;">Última transação</div>
            <div>Tx: <a id="txLink" href="#" target="_blank" rel="noreferrer">-</a></div>
          </div>

          <!-- ✅ NOVO: Status “humano” (sem Mongo/On-chain) -->
          <div id="userStatusBox" class="muted" style="margin-top:12px;">
            <div class="badge" style="margin-bottom:8px;">Status da assinatura</div>
            <div>Assinatura: <b id="uiSubStatus">-</b></div>
            <div>Renovação automática: <b id="uiAuto">-</b></div>
            <div>Próxima renovação: <b id="uiDue">-</b></div>
          </div>

          <!-- ✅ BLOCO TÉCNICO (mantido para não quebrar JS, mas oculto via CSS) -->
          <div id="statusBox" class="muted" style="margin-top:12px;">
            <div class="badge" style="margin-bottom:8px;">Status da sua conta</div>
            <div>Status (Mongo): <b id="accStatus">-</b></div>
            <div>Renovação automática (Mongo): <b id="accAuto">-</b></div>
            <div>Vencimento (Mongo): <b id="accDue">-</b></div>

            <div style="height:10px"></div>

            <div>Status (On-chain): <b id="onActive">-</b></div>
            <div>Due (On-chain): <b id="onDue">-</b></div>
            <div>Ativo até (On-chain): <b id="onNext">-</b></div>
          </div>

          <div style="margin-top:14px;">
            <a class="btn ghost" href="/dashboard.html" style="display:inline-block;">Ir para dashboard</a>
          </div>
        </div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="/assets/ui.js"></script>

  <script type="module">
    import { api, getToken, setToken, assinaturaApi } from "/assets/api.js";
    import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.4/+esm";

    function toast(msg, type){
      const el = document.getElementById('toast');
      if (!el) return;
      el.className = 'toast show' + (type === 'error' ? ' error' : '');
      el.textContent = msg;
      setTimeout(()=>{ el.className='toast'; }, 4500);
    }

    (function captureT(){
      try{
        const u = new URL(location.href);
        const t = u.searchParams.get("t");
        if (t && t.trim()){
          setToken(t.trim());
          u.searchParams.delete("t");
          history.replaceState({}, "", u.toString());
        }
      }catch{}
    })();

    function getMetaMaskDappLink(){
      const t = getToken();
      const u = new URL(location.href);
      if (t) u.searchParams.set("t", t);
      const clean = u.toString().replace(/^https?:\/\//, '');
      return 'https://metamask.app.link/dapp/' + clean;
    }

    // BSC
    const BSC_CHAIN_ID_HEX = '0x38';
    const BSC_PARAMS = {
      chainId: BSC_CHAIN_ID_HEX,
      chainName: 'BNB Chain',
      nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
      rpcUrls: ['https://bsc-dataseed.binance.org/'],
      blockExplorerUrls: ['https://bscscan.com']
    };

    // ✅ leitura de saldos por RPC público (não depende do MetaMask)
    // se algum estiver fora, ele tenta o próximo
    const BSC_PUBLIC_RPCS = [
      "https://bsc-dataseed.binance.org/",
      "https://bsc-dataseed1.binance.org/",
      "https://bsc-dataseed2.binance.org/",
      "https://bsc-dataseed3.binance.org/",
      "https://bsc-dataseed4.binance.org/",
    ];

    function getReadProvider(){
      // cria um provider novo e barato a cada chamada (sem estado)
      const url = BSC_PUBLIC_RPCS[Math.floor(Math.random() * BSC_PUBLIC_RPCS.length)];
      return new ethers.JsonRpcProvider(url);
    }

    async function ensureBsc(){
      if (!window.ethereum) throw new Error('MetaMask não detectado.');
      try{
        const current = await ethereum.request({ method:'eth_chainId' });
        if (current === BSC_CHAIN_ID_HEX) return true;
        await ethereum.request({ method:'wallet_switchEthereumChain', params:[{ chainId: BSC_CHAIN_ID_HEX }] });
        return true;
      }catch(err){
        if (err && err.code === 4902){
          await ethereum.request({ method:'wallet_addEthereumChain', params:[BSC_PARAMS] });
          return true;
        }
        throw err;
      }
    }

    async function refreshNetBadge(){
      const badge = document.getElementById('netBadge');
      if (!badge) return;
      try{
        if (!window.ethereum){
          badge.innerHTML = 'Rede: <b style="margin-left:6px">-</b>';
          return;
        }
        const chainId = await ethereum.request({ method:'eth_chainId' });
        const label = (chainId === BSC_CHAIN_ID_HEX) ? 'BNB Chain' : ('Chain ' + chainId);
        badge.innerHTML = 'Rede: <b style="margin-left:6px">' + label + '</b>';
      }catch{
        badge.innerHTML = 'Rede: <b style="margin-left:6px">-</b>';
      }
    }

    function isValidAddress(v){
      return /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
    }

    function setWalletInput(addr){
      const input = document.getElementById('walletInput');
      if (input && addr) input.value = addr;
    }

    function showBalancesBox({ bnb, usdt, hintText }){
      document.getElementById('balancesBox').style.display = 'block';
      document.getElementById('balBNB').textContent = bnb ?? '-';
      document.getElementById('balUSDT').textContent = usdt ?? '-';

      const hint = document.getElementById('balHint');
      if (hint) {
        hint.style.display = hintText ? 'block' : 'none';
        hint.textContent = hintText || '';
      }
    }

    function setStatusUI(me){
      const st = document.getElementById('accStatus');
      const au = document.getElementById('accAuto');
      const du = document.getElementById('accDue');

      const uiSt = document.getElementById('uiSubStatus');
      const uiAu = document.getElementById('uiAuto');
      const uiDu = document.getElementById('uiDue');

      const sub = me?.user?.subscription || me?.subscription || null;

      const status = (sub?.status || 'inactive');
      const auto = !!sub?.renovacaoAutomatica;
      const dueRaw = sub?.currentPeriodEnd || '-';

      if (st) st.textContent = status;
      if (au) au.textContent = auto ? 'SIM' : 'NÃO';
      if (du) du.textContent = dueRaw;

      if (uiSt) uiSt.textContent = (status === 'active') ? 'Ativa' : 'Inativa';
      if (uiAu) uiAu.textContent = auto ? 'Ativada' : 'Desativada';

      if (uiDu) {
        if (!dueRaw || dueRaw === '-') {
          uiDu.textContent = '-';
        } else {
          try {
            const d = new Date(dueRaw);
            if (!isNaN(d.getTime())) uiDu.textContent = d.toLocaleString();
            else uiDu.textContent = String(dueRaw);
          } catch {
            uiDu.textContent = String(dueRaw);
          }
        }
      }
    }

    function setOnchainUI(on){
      const a = document.getElementById('onActive');
      const d = document.getElementById('onDue');
      const n = document.getElementById('onNext');
      if (!a || !d || !n) return;

      if (!on) {
        a.textContent = '-';
        d.textContent = '-';
        n.textContent = '-';
        return;
      }

      const fmt = (v) => (v === null || v === undefined) ? '-' : (v ? 'SIM' : 'NÃO');

      a.textContent = (on.active === null) ? 'indisponível' : fmt(on.active);
      d.textContent = (on.due === null) ? 'indisponível' : fmt(on.due);

      if (on.nextDueAtISO) {
        try { n.textContent = new Date(on.nextDueAtISO).toLocaleString(); }
        catch { n.textContent = on.nextDueAtISO; }
      } else {
        n.textContent = (on.nextDueAt === null) ? 'indisponível' : '-';
      }
    }

    function showTx(hash){
      const box = document.getElementById('txBox');
      const link = document.getElementById('txLink');
      if (!box || !link) return;

      if (!hash) {
        box.style.display = 'none';
        return;
      }

      const url = 'https://bscscan.com/tx/' + hash;
      link.href = url;
      link.textContent = hash.slice(0,10) + '...' + hash.slice(-8);
      box.style.display = 'block';
    }

    async function apiGetMe(){
      return api('/api/me');
    }

    async function apiSaveWallet(walletAddress){
      return api('/api/me/wallet', { method:'POST', body:{ walletAddress } });
    }

    // ========= Web3 helpers =========
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 value) returns (bool)",
      "function decimals() view returns (uint8)"
    ];

    const SUBSCRIBE_ABI = [
      "function subscribe(address referrer)",
      "function renew()"
    ];

    // ✅ assinatura pelo MetaMask
    function getBrowserProvider(){
      if (!window.ethereum) throw new Error("MetaMask não detectado.");
      return new ethers.BrowserProvider(window.ethereum);
    }

    // ✅ conta conectada (sem popup)
    async function getConnectedAccount(){
      if (!window.ethereum) return null;
      const accounts = await ethereum.request({ method:'eth_accounts' });
      const from = accounts?.[0];
      return from ? ethers.getAddress(from) : null;
    }

    // ✅ conecta (popup)
    async function connectAndGetAccount(){
      const accounts = await ethereum.request({ method:'eth_requestAccounts' });
      const from = accounts?.[0];
      if (!from) throw new Error('Selecione uma conta no MetaMask.');
      return ethers.getAddress(from);
    }

    // ✅ leitura de saldos por RPC público (funciona com qualquer carteira 0x...)
    async function readBalances({ walletAddress, tokenAddress }){
      const provider = getReadProvider();

      const bnbWei = await provider.getBalance(walletAddress);
      const bnb = ethers.formatEther(bnbWei);

      const erc20 = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
      let dec = 18;
      try { dec = Number(await erc20.decimals()); } catch {}
      const usdtRaw = await erc20.balanceOf(walletAddress);
      const usdt = ethers.formatUnits(usdtRaw, dec);

      return { bnb, usdt, decimals: dec, usdtRaw: usdtRaw.toString() };
    }

    // ✅ leitura de allowance por RPC público
    async function readAllowance({ walletAddress, tokenAddress, spender }){
      const provider = getReadProvider();
      const erc20 = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
      const allowance = await erc20.allowance(walletAddress, spender);
      return allowance;
    }

    // ✅ approve/subscribe/renew por MetaMask
    async function sendApprove({ tokenAddress, spender, amount }){
      const provider = getBrowserProvider();
      const signer = await provider.getSigner();
      const erc20 = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      const tx = await erc20.approve(spender, amount);
      return tx.hash;
    }

    async function sendSubscribe({ contractAddress, referrer }){
      const provider = getBrowserProvider();
      const signer = await provider.getSigner();
      const c = new ethers.Contract(contractAddress, SUBSCRIBE_ABI, signer);
      const tx = await c.subscribe(referrer);
      return tx.hash;
    }

    async function sendRenew({ contractAddress }){
      const provider = getBrowserProvider();
      const signer = await provider.getSigner();
      const c = new ethers.Contract(contractAddress, SUBSCRIBE_ABI, signer);
      const tx = await c.renew();
      return tx.hash;
    }

    async function refreshOnchainStatus(){
      try{
        const data = await assinaturaApi.getOnchainStatus();
        setOnchainUI(data?.onchain || null);
        return data;
      }catch(e){
        setOnchainUI(null);
        return null;
      }
    }

    async function loadContractInfo(){
      const info = await assinaturaApi.getContractInfo();
      if (!info?.ok) throw new Error('Contrato indisponível no backend.');
      return info;
    }

    async function prepareFlow(walletAddress){
      const flow = await assinaturaApi.prepareSubscribe({ walletAddress });
      if (!flow?.ok) throw new Error('Não foi possível preparar a assinatura.');
      return flow;
    }

    // ✅ verifica saldos do endereço do input (QUALQUER carteira)
    async function refreshBalancesForInputWallet(){
      await apiGetMe();

      const wallet = (document.getElementById('walletInput').value || '').trim();
      if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (0x...).');

      const contractInfo = await loadContractInfo();
      const tokenAddress = contractInfo?.token || contractInfo?.USDT_ADDRESS || null;
      if (!tokenAddress || !isValidAddress(tokenAddress)) throw new Error('Token USDT indisponível.');

      const b = await readBalances({ walletAddress: wallet, tokenAddress });
      showBalancesBox({
        bnb: b.bnb,
        usdt: b.usdt,
        hintText: 'Saldos lidos direto da BNB Chain (RPC público).'
      });

      return { wallet, tokenAddress, balances: b };
    }

    // ✅ mantém a lógica original de UX, mas garante que na hora de assinar
    // a conta do MetaMask seja a que realmente vai pagar
    function ensureInputMatchesSelected(selected){
      const typed = (document.getElementById('walletInput').value || '').trim();
      if (isValidAddress(typed) && typed.toLowerCase() !== selected.toLowerCase()){
        // não quebra: avisa e corrige
        toast('A conta ativa no MetaMask é diferente da carteira do campo. Vou usar a conta ativa para assinar.', 'error');
        setWalletInput(selected);
      } else if (!typed) {
        setWalletInput(selected);
      }
    }

    // ========= init =========
    (async function init(){
      document.getElementById('btnOpenMM')?.addEventListener('click', ()=>{
        location.href = getMetaMaskDappLink();
      });

      await refreshNetBadge();

      if (window.ethereum){
        ethereum.on?.('chainChanged', async ()=>{
          await refreshNetBadge();
        });

        ethereum.on?.('accountsChanged', async (accounts)=>{
          const addr = accounts?.[0];
          if (!addr) return;
          const checksum = ethers.getAddress(addr);
          ensureInputMatchesSelected(checksum);
          toast('Conta alterada: ' + checksum.slice(0,6) + '...' + checksum.slice(-4));
        });
      }

      try{
        const me = await apiGetMe();
        setStatusUI(me);

        const saved = me?.user?.walletAddress || me?.walletAddress || null;
        if (saved && isValidAddress(saved)){
          document.getElementById('walletInput').value = saved;
          const info = document.getElementById('savedInfo');
          info.style.display = 'block';
          info.innerHTML = 'Carteira salva: <b>' + saved + '</b>';
        }

        await loadContractInfo();
        await refreshOnchainStatus();

        // ✅ se já estiver conectado, tenta espelhar a conta (sem forçar)
        const connected = await getConnectedAccount();
        if (connected && !document.getElementById('walletInput').value.trim()){
          setWalletInput(connected);
        }
      }catch(e){
        toast(e?.message || 'Não autenticado.', 'error');
      }
    })();

    document.getElementById('btnConnect')?.addEventListener('click', async ()=>{
      try{
        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }
        await ensureBsc();
        const acc = await connectAndGetAccount();
        ensureInputMatchesSelected(acc);
        toast('Carteira conectada: ' + acc.slice(0,6) + '...' + acc.slice(-4));
        await refreshNetBadge();
      }catch(err){
        toast(err?.message || 'Falha ao conectar MetaMask.', 'error');
      }
    });

    document.getElementById('btnSave')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();

        // ✅ salvar o que está no campo (mantém seu comportamento atual)
        const wallet = (document.getElementById('walletInput').value || '').trim();
        if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (começa com 0x...).');

        await apiSaveWallet(wallet);

        const info = document.getElementById('savedInfo');
        info.style.display = 'block';
        info.innerHTML = 'Carteira salva: <b>' + wallet + '</b>';

        toast('Carteira salva com sucesso.');
      }catch(err){
        toast(err?.message || 'Falha ao salvar carteira.', 'error');
      }
    });

    // ✅ Verificar saldos: agora funciona para QUALQUER carteira colada no campo
    document.getElementById('btnCheck')?.addEventListener('click', async ()=>{
      try{
        await refreshBalancesForInputWallet();
        toast('Saldos atualizados.');
      }catch(err){
        toast(err?.message || 'Falha ao verificar saldos.', 'error');
      }
    });

    document.getElementById('btnRefresh')?.addEventListener('click', async ()=>{
      try{
        const me = await apiGetMe();
        setStatusUI(me);
        await refreshOnchainStatus();
        toast('Status atualizado.');
      }catch(e){
        toast(e?.message || 'Falha ao atualizar status.', 'error');
      }
    });

    document.getElementById('btnSubscribe')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();

        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }

        await ensureBsc();
        await refreshNetBadge();

        // ✅ sempre assina com a conta ativa no MetaMask
        const selected = await connectAndGetAccount();
        ensureInputMatchesSelected(selected);

        // ✅ usa a carteira do campo como "carteira da conta" no backend,
        // mas garantimos que ela está igual ao selected (ou corrigimos)
        const wallet = (document.getElementById('walletInput').value || '').trim();
        if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (0x...).');

        await apiSaveWallet(wallet);

        const flow = await prepareFlow(wallet);

        const contractAddress = flow.contractAddress;
        const tokenAddress = flow.tokenAddress;
        const referrer = flow.referrerAddress || ethers.ZeroAddress;
        const total = BigInt(flow.total);

        if (!isValidAddress(contractAddress) || !isValidAddress(tokenAddress)) {
          throw new Error('Contrato/token inválidos no backend.');
        }

        // ✅ checagem de saldo via RPC público (não depende MetaMask)
        const bal = await readBalances({ walletAddress: wallet, tokenAddress });
        const usdtRaw = BigInt(bal.usdtRaw);

        if (usdtRaw < total) {
          const needHuman = ethers.formatUnits(total, bal.decimals || 18);
          showBalancesBox({
            bnb: bal.bnb,
            usdt: bal.usdt,
            hintText: `Você precisa de ~${needHuman} USDT (inclui taxa do contrato). Seu saldo atual é ${bal.usdt} USDT.`
          });
          toast('Saldo USDT insuficiente para assinar (inclui taxa do contrato).', 'error');
          return;
        }

        // ✅ allowance via RPC público
        const allowance = await readAllowance({ walletAddress: wallet, tokenAddress, spender: contractAddress });
        const allow = BigInt(allowance.toString());

        if (allow < total) {
          toast('Confirme a autorização (approve) no MetaMask...');
          const h1 = await sendApprove({ tokenAddress, spender: contractAddress, amount: total });
          showTx(h1);
          toast('Approve enviado. Agora confirme a assinatura (subscribe)...');
        } else {
          toast('Approve já está OK. Indo para assinatura (subscribe)...');
        }

        const h2 = await sendSubscribe({ contractAddress, referrer });
        showTx(h2);
        toast('Subscribe enviado! Aguarde confirmar na rede e clique em "Atualizar status".');

        await refreshOnchainStatus();
      }catch(err){
        toast(err?.message || 'Não foi possível ativar a assinatura.', 'error');
      }
    });

    document.getElementById('btnRenew')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();

        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }

        await ensureBsc();
        await refreshNetBadge();

        const selected = await connectAndGetAccount();
        ensureInputMatchesSelected(selected);

        const info = await assinaturaApi.getContractInfo();
        if (!info?.ok) throw new Error('Contrato indisponível no backend.');

        const p = await assinaturaApi.getParams().catch(()=>null);
        const addr = (p?.contractAddress) || (info?.contractAddress) || null;

        const caddr = addr;
        if (!caddr || !isValidAddress(caddr)) throw new Error('Endereço do contrato inválido.');

        toast('Confirme a renovação (renew) no MetaMask...');
        const h = await sendRenew({ contractAddress: caddr });
        showTx(h);
        toast('Renew enviado! Aguarde confirmar e clique em "Atualizar status".');

        await refreshOnchainStatus();
      }catch(err){
        toast(err?.message || 'Falha ao renovar.', 'error');
      }
    });
  </script>
</body>
</html>
