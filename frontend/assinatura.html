<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ativar assinatura</title>
  <link rel="stylesheet" href="/assets/app.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="topbar">
        <div class="brand">
          <span class="dot"></span>
          <div>
            <div style="font-size:18px; line-height:1; font-weight:900;">Liberdade Financeira</div>
            <div class="muted small">Ativar assinatura</div>
          </div>
        </div>
        <div class="badge" id="netBadge">Rede: <b style="margin-left:6px">-</b></div>
      </div>

      <div class="section grid" style="gap:18px;">
        <div>
          <h1 style="margin:0 0 6px;font-size:34px;letter-spacing:-0.02em;">Ativar assinatura</h1>
          <p class="muted" style="margin:0;">
            Para liberar o acesso ao dashboard, você vai usar <b>uma única carteira</b>:
            ela será usada para <b>pagar a assinatura</b> e também para <b>receber suas comissões</b>.
          </p>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">No celular</div>
          <div class="muted" style="margin-bottom:10px;">
            Para assinar pelo celular, o ideal é abrir esta página dentro do navegador do MetaMask.
          </div>
          <button class="btn primary" id="btnOpenMM">Abrir no MetaMask</button>
          <div class="small muted" style="margin-top:10px;">
            Se aparecer um aviso “prossiga com cautela”, é normal: você está abrindo um dApp externo.
          </div>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">Antes de continuar</div>

          <div class="grid" style="gap:10px;">
            <div class="muted">
              <b>Você precisa ter na sua carteira:</b><br/>
              • <b>BNB</b> (taxas de rede)<br/>
              • <b>USDT</b> (assinatura)
            </div>

            <div class="muted">
              ✅ Forma mais simples de preparar (recomendado):<br/>
              1) Deposite <b>15 USDT</b> na sua carteira<br/>
              2) Troque uma pequena parte por <b>BNB</b> (taxas de rede)<br/>
              3) Deixe o restante em <b>USDT</b> para a assinatura
            </div>

            <div class="small muted">
              <b>Taxa de rede:</b> na primeira autorização (approve), será cobrada uma taxa pequena em <b>BNB</b>.
            </div>
          </div>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">Carteira principal</div>

          <div class="muted" style="margin-bottom:10px;">
            Cole abaixo o endereço da sua carteira (0x...). Se preferir, você pode conectar o MetaMask
            para preencher automaticamente.
          </div>

          <input class="input" id="walletInput" placeholder="Cole aqui o endereço (0x...)" />

          <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;">
            <button class="btn" id="btnConnect">Conectar MetaMask (opcional)</button>
            <button class="btn" id="btnSave">Salvar carteira</button>
            <button class="btn ghost" id="btnCheck">Verificar saldos</button>
          </div>

          <div class="muted small" id="savedInfo" style="margin-top:10px;display:none;"></div>

          <div class="muted" id="balancesBox" style="margin-top:10px;display:none;">
            <div class="badge" style="margin-bottom:8px;">Saldos</div>
            <div>• BNB: <b id="balBNB">-</b></div>
            <div>• USDT: <b id="balUSDT">-</b></div>
            <div class="small muted" id="balHint" style="margin-top:8px;display:none;"></div>
          </div>
        </div>

        <div class="card" style="padding:16px;">
          <div class="badge" style="margin-bottom:10px;">Ativar acesso</div>

          <button class="btn primary" id="btnSubscribe" style="width:100%;font-size:18px;">
            Ativar assinatura
          </button>

          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;">
            <button class="btn ghost" id="btnRenew" style="flex:1; min-width:220px;">
              Renovar agora
            </button>
            <button class="btn ghost" id="btnRefresh" style="flex:1; min-width:220px;">
              Atualizar status
            </button>
          </div>

          <div class="small muted" style="margin-top:10px;">
            No primeiro uso, o MetaMask vai pedir uma confirmação extra para autorizar o débito do USDT (approve).
            Depois, você assina a transação de assinatura (subscribe) e o acesso é liberado.
          </div>

          <div id="txBox" class="muted" style="margin-top:12px; display:none;">
            <div class="badge" style="margin-bottom:8px;">Última transação</div>
            <div>Tx: <a id="txLink" href="#" target="_blank" rel="noreferrer">-</a></div>
          </div>

          <div id="statusBox" class="muted" style="margin-top:12px;">
            <div class="badge" style="margin-bottom:8px;">Status da sua conta</div>
            <div>Status (Mongo): <b id="accStatus">-</b></div>
            <div>Renovação automática (Mongo): <b id="accAuto">-</b></div>
            <div>Vencimento (Mongo): <b id="accDue">-</b></div>

            <div style="height:10px"></div>

            <div>Status (On-chain): <b id="onActive">-</b></div>
            <div>Due (On-chain): <b id="onDue">-</b></div>
            <div>Ativo até (On-chain): <b id="onNext">-</b></div>
          </div>

          <div style="margin-top:14px;">
            <a class="btn ghost" href="/dashboard.html" style="display:inline-block;">Ir para dashboard</a>
          </div>
        </div>
      </div>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="/assets/ui.js"></script>

  <script type="module">
    import { api, getToken, setToken, assinaturaApi } from "/assets/api.js";
    import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.4/+esm";

    function toast(msg, type){
      const el = document.getElementById('toast');
      if (!el) return;
      el.className = 'toast show' + (type === 'error' ? ' error' : '');
      el.textContent = msg;
      setTimeout(()=>{ el.className='toast'; }, 4500);
    }

    // mantém compatibilidade do token na URL (já existia)
    (function captureT(){
      try{
        const u = new URL(location.href);
        const t = u.searchParams.get("t");
        if (t && t.trim()){
          setToken(t.trim());
          u.searchParams.delete("t");
          history.replaceState({}, "", u.toString());
        }
      }catch{}
    })();

    function getMetaMaskDappLink(){
      const t = getToken();
      const u = new URL(location.href);
      if (t) u.searchParams.set("t", t);
      const clean = u.toString().replace(/^https?:\/\//, '');
      return 'https://metamask.app.link/dapp/' + clean;
    }

    // BSC
    const BSC_CHAIN_ID_HEX = '0x38';
    const BSC_PARAMS = {
      chainId: BSC_CHAIN_ID_HEX,
      chainName: 'BNB Chain',
      nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
      rpcUrls: ['https://bsc-dataseed.binance.org/'],
      blockExplorerUrls: ['https://bscscan.com']
    };

    async function ensureBsc(){
      if (!window.ethereum) throw new Error('MetaMask não detectado.');
      try{
        const current = await ethereum.request({ method:'eth_chainId' });
        if (current === BSC_CHAIN_ID_HEX) return true;
        await ethereum.request({ method:'wallet_switchEthereumChain', params:[{ chainId: BSC_CHAIN_ID_HEX }] });
        return true;
      }catch(err){
        if (err && err.code === 4902){
          await ethereum.request({ method:'wallet_addEthereumChain', params:[BSC_PARAMS] });
          return true;
        }
        throw err;
      }
    }

    async function refreshNetBadge(){
      const badge = document.getElementById('netBadge');
      if (!badge) return;
      try{
        if (!window.ethereum){
          badge.innerHTML = 'Rede: <b style="margin-left:6px">-</b>';
          return;
        }
        const chainId = await ethereum.request({ method:'eth_chainId' });
        const label = (chainId === BSC_CHAIN_ID_HEX) ? 'BNB Chain' : ('Chain ' + chainId);
        badge.innerHTML = 'Rede: <b style="margin-left:6px">' + label + '</b>';
      }catch{
        badge.innerHTML = 'Rede: <b style="margin-left:6px">-</b>';
      }
    }

    function isValidAddress(v){
      return /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
    }

    function setStatusUI(me){
      const st = document.getElementById('accStatus');
      const au = document.getElementById('accAuto');
      const du = document.getElementById('accDue');
      if (!st || !au || !du) return;

      const sub = me?.user?.subscription || me?.subscription || null;
      st.textContent = sub?.status || 'inactive';
      const auto = sub?.renovacaoAutomatica;
      au.textContent = auto ? 'SIM' : 'NÃO';
      du.textContent = sub?.currentPeriodEnd || '-';
    }

    function setOnchainUI(on){
      const a = document.getElementById('onActive');
      const d = document.getElementById('onDue');
      const n = document.getElementById('onNext');
      if (!a || !d || !n) return;

      if (!on) {
        a.textContent = '-';
        d.textContent = '-';
        n.textContent = '-';
        return;
      }

      const fmt = (v) => (v === null || v === undefined) ? '-' : (v ? 'SIM' : 'NÃO');

      a.textContent = (on.active === null) ? 'indisponível' : fmt(on.active);
      d.textContent = (on.due === null) ? 'indisponível' : fmt(on.due);

      if (on.nextDueAtISO) {
        // mostra local
        try {
          n.textContent = new Date(on.nextDueAtISO).toLocaleString();
        } catch {
          n.textContent = on.nextDueAtISO;
        }
      } else {
        n.textContent = (on.nextDueAt === null) ? 'indisponível' : '-';
      }
    }

    function showTx(hash){
      const box = document.getElementById('txBox');
      const link = document.getElementById('txLink');
      if (!box || !link) return;

      if (!hash) {
        box.style.display = 'none';
        return;
      }

      const url = 'https://bscscan.com/tx/' + hash;
      link.href = url;
      link.textContent = hash.slice(0,10) + '...' + hash.slice(-8);
      box.style.display = 'block';
    }

    async function apiGetMe(){
      return api('/api/me');
    }

    async function apiSaveWallet(walletAddress){
      return api('/api/me/wallet', { method:'POST', body:{ walletAddress } });
    }

    // ========= Web3 helpers (no browser) =========
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address owner, address spender) view returns (uint256)",
      "function approve(address spender, uint256 value) returns (bool)",
      "function decimals() view returns (uint8)"
    ];

    const SUBSCRIBE_ABI = [
      "function subscribe(address referrer)",
      "function renew()"
    ];

    function getBrowserProvider(){
      if (!window.ethereum) throw new Error("MetaMask não detectado.");
      return new ethers.BrowserProvider(window.ethereum);
    }

    async function getSelectedAccount(){
      const accounts = await ethereum.request({ method:'eth_requestAccounts' });
      const from = accounts?.[0];
      if (!from) throw new Error('Selecione uma conta no MetaMask.');
      return ethers.getAddress(from);
    }

    async function readBalances({ walletAddress, tokenAddress }){
      const provider = getBrowserProvider();

      // BNB
      const bnbWei = await provider.getBalance(walletAddress);
      const bnb = ethers.formatEther(bnbWei);

      // USDT
      const erc20 = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
      let dec = 18;
      try { dec = Number(await erc20.decimals()); } catch {}
      const usdtRaw = await erc20.balanceOf(walletAddress);
      const usdt = ethers.formatUnits(usdtRaw, dec);

      return { bnb, usdt, decimals: dec, usdtRaw: usdtRaw.toString() };
    }

    async function readAllowance({ walletAddress, tokenAddress, spender }){
      const provider = getBrowserProvider();
      const erc20 = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
      const allowance = await erc20.allowance(walletAddress, spender);
      return allowance; // bigint-like
    }

    async function sendApprove({ tokenAddress, spender, amount }){
      const provider = getBrowserProvider();
      const signer = await provider.getSigner();
      const erc20 = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      const tx = await erc20.approve(spender, amount);
      return tx.hash;
    }

    async function sendSubscribe({ contractAddress, referrer }){
      const provider = getBrowserProvider();
      const signer = await provider.getSigner();
      const c = new ethers.Contract(contractAddress, SUBSCRIBE_ABI, signer);
      const tx = await c.subscribe(referrer);
      return tx.hash;
    }

    async function sendRenew({ contractAddress }){
      const provider = getBrowserProvider();
      const signer = await provider.getSigner();
      const c = new ethers.Contract(contractAddress, SUBSCRIBE_ABI, signer);
      const tx = await c.renew();
      return tx.hash;
    }

    async function refreshOnchainStatus(){
      try{
        const data = await assinaturaApi.getOnchainStatus();
        setOnchainUI(data?.onchain || null);
        return data;
      }catch(e){
        setOnchainUI(null);
        return null;
      }
    }

    // ========= init =========
    let CONTRACT = null; // {contractAddress, tokenAddress, price, txFeeBps, total, referrerAddress}

    async function loadContractInfo(){
      // Preferimos o prepare/params do backend (fonte única)
      const info = await assinaturaApi.getContractInfo();
      if (!info?.ok) throw new Error('Contrato indisponível no backend.');
      return info;
    }

    async function prepareFlow(walletAddress){
      // backend resolve referrer e calcula total
      const flow = await assinaturaApi.prepareSubscribe({ walletAddress });
      if (!flow?.ok) throw new Error('Não foi possível preparar a assinatura.');
      return flow;
    }

    (async function init(){
      document.getElementById('btnOpenMM')?.addEventListener('click', ()=>{
        location.href = getMetaMaskDappLink();
      });

      await refreshNetBadge();
      if (window.ethereum){
        ethereum.on?.('chainChanged', ()=>{ refreshNetBadge(); });
      }

      try{
        const me = await apiGetMe();
        setStatusUI(me);

        const saved = me?.user?.walletAddress || me?.walletAddress || null;
        if (saved && isValidAddress(saved)){
          document.getElementById('walletInput').value = saved;
          const info = document.getElementById('savedInfo');
          info.style.display = 'block';
          info.innerHTML = 'Carteira salva: <b>' + saved + '</b>';
        }

        // carrega info do contrato
        await loadContractInfo();

        // status on-chain (best-effort)
        await refreshOnchainStatus();
      }catch(e){
        toast(e?.message || 'Não autenticado.', 'error');
      }
    })();

    document.getElementById('btnConnect')?.addEventListener('click', async ()=>{
      try{
        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }
        await ensureBsc();
        const acc = await getSelectedAccount();
        document.getElementById('walletInput').value = acc;
        toast('Carteira conectada: ' + acc.slice(0,6) + '...' + acc.slice(-4));
        await refreshNetBadge();
      }catch(err){
        toast(err?.message || 'Falha ao conectar MetaMask.', 'error');
      }
    });

    document.getElementById('btnSave')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();
        const wallet = document.getElementById('walletInput').value.trim();
        if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (começa com 0x...).');

        await apiSaveWallet(wallet);

        const info = document.getElementById('savedInfo');
        info.style.display = 'block';
        info.innerHTML = 'Carteira salva: <b>' + wallet + '</b>';

        toast('Carteira salva com sucesso.');
      }catch(err){
        toast(err?.message || 'Falha ao salvar carteira.', 'error');
      }
    });

    document.getElementById('btnCheck')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();

        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }

        await ensureBsc();
        await refreshNetBadge();

        const wallet = document.getElementById('walletInput').value.trim();
        if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (0x...).');

        const contractInfo = await loadContractInfo();

        // token do backend é a fonte de verdade
        const tokenAddress = contractInfo?.token || contractInfo?.USDT_ADDRESS || null;
        if (!tokenAddress || !isValidAddress(tokenAddress)) throw new Error('Token USDT indisponível.');

        const b = await readBalances({ walletAddress: wallet, tokenAddress });

        document.getElementById('balancesBox').style.display = 'block';
        document.getElementById('balBNB').textContent = b.bnb;
        document.getElementById('balUSDT').textContent = b.usdt;

        const hint = document.getElementById('balHint');
        if (hint) {
          hint.style.display = 'block';
          hint.textContent = 'Se BNB estiver baixo, você não consegue pagar as taxas de approve/subscribe/renew.';
        }

        toast('Saldos atualizados.');
      }catch(err){
        toast(err?.message || 'Falha ao verificar saldos.', 'error');
      }
    });

    document.getElementById('btnRefresh')?.addEventListener('click', async ()=>{
      try{
        const me = await apiGetMe();
        setStatusUI(me);
        await refreshOnchainStatus();
        toast('Status atualizado.');
      }catch(e){
        toast(e?.message || 'Falha ao atualizar status.', 'error');
      }
    });

    document.getElementById('btnSubscribe')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();

        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }

        await ensureBsc();
        await refreshNetBadge();

        const selected = await getSelectedAccount();

        const wallet = document.getElementById('walletInput').value.trim();
        if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (0x...).');

        // UX: exige que a conta selecionada seja a mesma da wallet do input
        if (selected.toLowerCase() !== wallet.toLowerCase()) {
          throw new Error('A conta ativa no MetaMask é diferente da carteira informada. Troque a conta no MetaMask.');
        }

        // salva wallet no backend
        await apiSaveWallet(wallet);

        // prepara fluxo no backend (referrer + total)
        const flow = await prepareFlow(wallet);

        const contractAddress = flow.contractAddress;
        const tokenAddress = flow.tokenAddress;
        const referrer = flow.referrerAddress || ethers.ZeroAddress;
        const total = BigInt(flow.total);

        if (!isValidAddress(contractAddress) || !isValidAddress(tokenAddress)) {
          throw new Error('Contrato/token inválidos no backend.');
        }

        // 1) check saldos (BNB + USDT)
        const bal = await readBalances({ walletAddress: wallet, tokenAddress });
        const usdtRaw = BigInt(bal.usdtRaw);

        // check USDT suficiente
        if (usdtRaw < total) {
          toast('Saldo USDT insuficiente para assinar (inclui taxa do contrato).', 'error');
          document.getElementById('balancesBox').style.display = 'block';
          document.getElementById('balBNB').textContent = bal.bnb;
          document.getElementById('balUSDT').textContent = bal.usdt;
          return;
        }

        // 2) approve exato (se necessário)
        const allowance = await readAllowance({ walletAddress: wallet, tokenAddress, spender: contractAddress });
        const allow = BigInt(allowance.toString());

        if (allow < total) {
          toast('Confirme a autorização (approve) no MetaMask...');
          const h1 = await sendApprove({ tokenAddress, spender: contractAddress, amount: total });
          showTx(h1);
          toast('Approve enviado. Agora confirme a assinatura (subscribe)...');

          // Não esperamos confirmar bloco aqui (sem indexer).
          // Só seguimos para subscribe; se o usuário preferir, pode clicar de novo.
        } else {
          toast('Approve já está OK. Indo para assinatura (subscribe)...');
        }

        // 3) subscribe(referrer)
        const h2 = await sendSubscribe({ contractAddress, referrer });
        showTx(h2);
        toast('Subscribe enviado! Aguarde confirmar na rede e clique em "Atualizar status".');

        // Atualiza status best-effort
        await refreshOnchainStatus();
      }catch(err){
        toast(err?.message || 'Não foi possível ativar a assinatura.', 'error');
      }
    });

    document.getElementById('btnRenew')?.addEventListener('click', async ()=>{
      try{
        await apiGetMe();

        if (!window.ethereum){
          toast('MetaMask não detectado. No celular, use "Abrir no MetaMask".', 'error');
          return;
        }

        await ensureBsc();
        await refreshNetBadge();

        const selected = await getSelectedAccount();
        const wallet = document.getElementById('walletInput').value.trim();
        if (!isValidAddress(wallet)) throw new Error('Cole um endereço válido (0x...).');
        if (selected.toLowerCase() !== wallet.toLowerCase()) {
          throw new Error('A conta ativa no MetaMask é diferente da carteira informada. Troque a conta no MetaMask.');
        }

        const info = await assinaturaApi.getContractInfo();
        if (!info?.ok) throw new Error('Contrato indisponível no backend.');

        // endereço do contrato é a fonte de verdade do backend
        const contractAddress = info.contractAddress || info.contractAddress || null;
        // fallback: reaproveita de /params se necessário
        const p = await assinaturaApi.getParams().catch(()=>null);
        const addr = (p?.contractAddress) || (info?.contractAddress) || null;

        const caddr = addr;
        if (!caddr || !isValidAddress(caddr)) throw new Error('Endereço do contrato inválido.');

        toast('Confirme a renovação (renew) no MetaMask...');
        const h = await sendRenew({ contractAddress: caddr });
        showTx(h);
        toast('Renew enviado! Aguarde confirmar e clique em "Atualizar status".');

        await refreshOnchainStatus();
      }catch(err){
        toast(err?.message || 'Falha ao renovar.', 'error');
      }
    });
  </script>
  <script type="module">
  import { attachBalanceButtons } from "/assets/balances.js";

  attachBalanceButtons({
    inputSelector: "#wallet",
    btnCheckSelector: "#btnCheckBalances",
    btnConnectSelector: "#btnConnectMetamask",
    outBnbSelector: "#outBnb",
    outUsdtSelector: "#outUsdt",
    outWalletSelector: "#outWalletSaved",
  });
</script>
</body>
</html>
